#include <iostream>
#include <cmath>

#include "TVector3.h"
#include "TFile.h"
#include "TTree.h"


int main(int argc, char** argv){
  if (argc != 3){
    std::cout << "wrong number of arguments\n";
    std::cout << "Try ./pseudo_skim_tree ../DATA/gen_file.root ../DATA/pseudo_skim_tree.root\n";
    return -1;
  }

// TTree to save values during the loop
  TFile * input_file = new TFile(argv[1]);
  TFile * outfile = new TFile(argv[2],"RECREATE");
  TTree * generator_tree = (TTree*)input_file->Get("genT");
  TTree * outtree = new TTree("massT", "Mass Tree");


// Define New Tree Variables for massT
  const int maxPart = 50;
  double mom_x[maxPart], mom_y[maxPart], mom_z[maxPart], vtx_z_cor[maxPart];
  int nParticles, Part_type[maxPart];
  double Xb, weighted, Q2;
  
//Variables we are saving (match skim_tree in E2A): "name", &variable, "name with elements"/double
  outtree->Branch("nParticles", &nParticles, "nParticles/I"            ); //number of particles detected, integer - for me it will always be two  
  outtree->Branch("Part_type" ,  Part_type , "Part_type[nParticles]/I" ); //neutron (2112) or proton (2212) or pion (0: 111 ; -: -211 ; +: 211) or electron (-11)
  outtree->Branch("vtx_z_cor" ,  vtx_z_cor , "vtx_z_cor[nParticles]/D" ); //vertext Z corrected, arrays of integer, length of nParticles
  outtree->Branch("mom_x"     ,  mom_x     , "mom_x[nParticles]/D"     ); //momentum in x direction, arrays of double, length of nParticles, GeV, final nucleon momentum
  outtree->Branch("mom_y"     ,  mom_y     , "mom_y[nParticles]/D"     ); //momentum in z direction, arrays of double, length of nParticles, GeV, final nucleon momentum
  outtree->Branch("mom_z"     ,  mom_z     , "mom_z[nParticles]/D"     ); //momentum in y direction, arrays of double, length of nParticles, GeV, final nucleon momentum
  outtree->Branch("Xb"        , &Xb        , "Xb/D"                    ); // Bjorken X
  outtree->Branch("Q2"        , &Q2        , "Q2/D"                    ); // Bjorken X
  outtree->Branch("weighted"  , &weighted , "weighted/D"              ); // weight  
  

// Define Old Tree Variables I need from genT
  int nucleon_type;
  double X_b, P1_prime_vec[3], P_k_vec[3], Q_2, weight;
  
// Get branch (values) from generator.cpp
  generator_tree->SetBranchAddress("X_b",&X_b);
  generator_tree->SetBranchAddress("nucleon_type",&nucleon_type);
  generator_tree->SetBranchAddress("P1_prime_vec",P1_prime_vec);
  generator_tree->SetBranchAddress("P_k_vec",P_k_vec);
  generator_tree->SetBranchAddress("weight",&weight);
  generator_tree->SetBranchAddress("Q_2",&Q_2);

  
// Loop over all entries
  for (int i = 0; i < generator_tree->GetEntries(); i++){   
    generator_tree->GetEvent(i);
    
    // Predefined for this situation; change if changed experiment
    Part_type[0] = -11.;
    Part_type[1] = nucleon_type; // scattered electron, scattered nucleon (proton or neutron)
    nParticles = 2.; //specific for Mean Field Generator - scattered electron and nucleon
    vtx_z_cor[1] = -1.; // tbd later on

    // Variable to take from old code
    Xb = X_b;
    Q2 = Q_2;
    weighted = weight;
    mom_x[0] = P_k_vec[0];
    mom_y[0] = P_k_vec[1];
    mom_z[0] = P_k_vec[2];
    mom_x[1] = P1_prime_vec[0];
    mom_y[1] = P1_prime_vec[1];
    mom_z[1] = P1_prime_vec[2];

    // Fill Tree
    outtree->Fill();}

    
// Clean up
  input_file->Close();
  outtree->Write();
  outfile->Close();
  return 0;
  
}






    

  /* 
     =========================
     Part_type values	(http://www.star.bnl.gov/public/comp/simu/newsite/gstar/kumacs/NewParticle.html)
     -11  = electron
     2212 = proton
     2112 = neutron
     +211 = pi+
     -211 = pi-
     +111 = pi0
     =========================
  */


/** Axel's Definitions:
  outtree->Branch("nRun"      , &nRun      , "nRun/I"                  );
  outtree->Branch("nParticles", &nParticles, "nParticles/I"            );
  outtree->Branch("nProtons"  , &nProtons  , "nProtons/I"              );
  outtree->Branch("nNeutrons" , &nNeutrons , "nNeutrons/I"             );
  outtree->Branch("nPiplus"   , &nPiplus   , "nPiplus/I"               );
  outtree->Branch("nPiminus"  , &nPiminus  , "nPiminus/I"              );
  outtree->Branch("t0"        , &t0        , "t0/D"                    );
  outtree->Branch("Nu"        , &Nu        , "Nu/D"                    );
  outtree->Branch("Q2"        , &Q2        , "Q2/D"                    );
  outtree->Branch("Xb"        , &Xb        , "Xb/D"                    );
  outtree->Branch("charge"    ,  charge    , "charge[nParticles]/D"    );
  outtree->Branch("beta"      ,  beta      , "beta[nParticles]/D"      );
  outtree->Branch("Part_type" ,  Part_type , "Part_type[nParticles]/I" );
  outtree->Branch("vtx_z_unc" ,  vtx_z_unc , "vtx_z_unc[nParticles]/D" );
  outtree->Branch("vtx_z_cor" ,  vtx_z_cor , "vtx_z_cor[nParticles]/D" );
  outtree->Branch("mom_x"     ,  mom_x     , "mom_x[nParticles]/D"     );
  outtree->Branch("mom_y"     ,  mom_y     , "mom_y[nParticles]/D"     );
  outtree->Branch("mom_z"     ,  mom_z     , "mom_z[nParticles]/D"     );
  outtree->Branch("phi"     ,  phi     , "phi[nParticles]/D"     );
  outtree->Branch("theta"     ,  theta     , "theta[nParticles]/D"     );
  outtree->Branch("e_deltat"  ,  e_deltat  , "e_deltat[nParticles]/D"  );
  outtree->Branch("stat_sc"   ,  stat_sc   , "stat_sc[nParticles]/I"   );
  outtree->Branch("stat_dc"   ,  stat_dc   , "stat_dc[nParticles]/I"   );
  outtree->Branch("stat_ec"   ,  stat_ec   , "stat_ec[nParticles]/I"   );
  outtree->Branch("sc_time"   ,  sc_time   , "sc_time[nParticles]/D"   );
  outtree->Branch("sc_path"   ,  sc_path   , "sc_path[nParticles]/D"   );
  outtree->Branch("sc_pad"    ,  sc_pad    , "sc_pad[nParticles]/I"    );
  outtree->Branch("ec_time"   ,  ec_time   , "ec_time[nParticles]/D"   );
  outtree->Branch("ec_path"   ,  ec_path   , "ec_path[nParticles]/D"   );
  outtree->Branch("ec_in"     ,  ec_in     , "ec_in[nParticles]/D"     );
  outtree->Branch("ec_out"    ,  ec_out    , "ec_out[nParticles]/D"    );
  outtree->Branch("ec_tot"    ,  ec_tot    , "ec_tot[nParticles]/D"    );
  outtree->Branch("ec_x"      ,  ec_x      , "ec_x[nParticles]/D"      );
  outtree->Branch("ec_y"      ,  ec_y      , "ec_y[nParticles]/D"      );
  outtree->Branch("ec_z"      ,  ec_z      , "ec_z[nParticles]/D"      );
  outtree->Branch("ec_u"      ,  ec_u      , "ec_u[nParticles]/D"      );
  outtree->Branch("ec_v"      ,  ec_v      , "ec_v[nParticles]/D"      );
  outtree->Branch("ec_w"      ,  ec_w      , "ec_w[nParticles]/D"      );
  outtree->Branch("Mass"      ,  Mass      , "Mass[nParticles]/D"      );

**/
